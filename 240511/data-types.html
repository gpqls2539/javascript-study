<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      "use strict";
      /**
       * 자바스크립트의 자료형
       *
       * string : 문자형, 빈문자열도 해당
       * number : 숫자형
       * boolean : 불리언 - true, false
       * object : 객체형 - 키와 값으로 이루어진 자료형
       * array : 배열 - 값으로만 이루어지고 길이를 가진 자료형
       * null : 빈값을 표현하는 자료형
       * undefined : 값을 찾을 수 없다는 자료형
       * function : 함수형 - 큰 범위로는 객체형에 해당
       *
       * 자료형은 크게는 원시타입과 객체타입으로 나뉘어진다.
       */

      // 원시타입 자료형 (문자, 숫자, 불리언)
      // 문자형
      const str = "my name is";
      const str2 = "hyebin";
      const emptyStr = ""; // 빈 문자열

      // 문자형은 서로 이어붙일 수 있다. (더하기)
      // 문자형은 유일하게 더하기에 대한 산술연산자(+)는 허용한다.

      console.log(str + " " + str2);

      // 숫자형
      // 모든 산술연산자를 허용
      // 양수, 음수, 소수점, 무한수(infinity)
      // NaN (Not a Number) - 숫자형인데 숫자로 표현할 수 없는 경우
      console.log(Number(str2));

      const num = 1;
      const num2 = 0;
      const num3 = -10;
      const num4 = 10.55;
      const num5 = Infinity;

      console.log(num, num2, num3, num4, num5);

      // 불리언
      console.log("true", true);
      console.log("false", false);

      // 문자형은 빈 문자열은 false로 해석한다.
      console.log("빈 문자열", !!"abcd"); // true
      console.log("빈 문자열", !!""); // false

      // 음수, 소수 여부와 상관없이 0은 false로 해석한다.
      console.log("숫자 10", !!10); // true
      console.log("숫자 0", !!0); // false
      console.log("숫자 0.123", !!0.123); // true

      // 객체타입 자료형(object, array, function)

      // 객체는 키가 반드시 필요하고 값은 자료형에 해당하면 뭐든 들어갈 수 있다.
      const obj = {
        a: "atr",
        b: 1,
        c: null,
        d: undefined,
        e: {},
        f: [],
        g: function () {},
      }; //object

      // 객체의 접근
      // 객체의 값도 원시타입이냐 객체타입이냐에 따라 메모리 저장 방식이 달라진다.
      const obj4 = {
        a: 1,
        b: {
          c: 2,
          d: {
            e: 3,
          },
        },
      };

      // 객체의 접근 방식은 체이닝 접근 방식 혹은 string 프로퍼티 접근 방식이 있다.
      // 체이닝 접근
      console.log("-------------체이닝 접근-------------");
      console.log(obj4.a);
      console.log(obj4.a.c); // 접근하려는 키가 없으니까 undefined

      console.log(obj4.b.c);
      console.log(obj4.b.d.e);

      // string 접근
      console.log("-------------string 접근-------------");
      console.log(obj4["a"]);
      console.log(obj4["b"]["c"]);
      console.log(obj4["b"]["d"]["e"]);

      const keys = {
        a: "a",
        b: "b",
      };

      console.log(obj4[keys.a]);

      console.log("-------------객체의 비교-------------");
      // 객체의 비교

      // 객체는 선언 시점에 참조 주소로 저장이 된다.
      const obj2 = {}; // ax0000
      const obj3 = {}; // ax0001
      // 2개의 참조 주소가 다르기 때문에 같은 객체 모양이더라도 다르다.

      console.log(obj2 === obj3);

      const copyObj2 = obj2; // {}
      // 참조 주소를 복사했기 때문에 같다.
      console.log(copyObj2 === obj2);

      const copyObj3 = obj3; // {}
      console.log(copyObj3 === obj2);

      console.log("-------------배열-------------");
      // 배열
      const arr = [1, "str", null, undefined, {}, [], function () {}]; // 대괄호 내에 값을 넣는다.
      // 배열도 마찬가지로 배열에 포함되는 값은 자료형에 해당되면 뭐든지 가능하다.
      // 길이를 가지고 있다.
      console.log(arr.length);

      // 배열의 접근
      const arr2 = [1, 2, 3, 4, 5, 6, 7, 8, 9];
      //배열은 index로만 접근 가능하다. (index는 무조건 0부터 시작)
      console.log("index1", arr2[1]);

      // 길이는 값 그대로이기 때문에 마지막 인덱스를 구하는 방법은 언제나 length - 1
      console.log("last index", arr2[arr2.length - 1]);
      const arr3 = [{ a: 1, b: 2 }, [4, 7, 9, { a: 9 }]];

      console.log("arr3 b", arr3[0].b);
      console.log("arr3 배열의 2번째 값", arr3[1][2]);
      console.log(arr3[1][3].a);

      // 배열의 비교
      const arr4 = [{ a: 1 }];
      const arr5 = [arr4[0]];

      console.log(arr4[0].a === arr5[0].a);
      console.log(arr4[0] === arr5[0]);
    </script>
  </body>
</html>
