<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      "use strict";

      /**
       * 객체의 복사
       * 객체는 기본적으로 참조 주소로 지정되고 하위 객체도 참조 주소가 생성됨
       * 복사라는 게 결국 하나의 변수를 다른 변수에 할당하는 것
       */

      // 원시 타입의 복사

      let num = 10;
      let num2 = num;

      num = 20;

      console.log("num", num); // 20
      console.log("num2", num2); // 10

      let str = "str";

      str = "str2";

      let str2 = str;

      console.log("str", str); // str2
      console.log("str2", str2); // str2

      // 객체 타입의 복사

      const obj = {
        a: 1,
        b: 2,
      };

      const obj2 = obj;

      obj.a = 10;

      console.log("obj2", obj2.a); // 10
      // 같은 참조 주소를 가진 객체로 인해 같이 변경된다.

      // 객체를 서로 분리하기 위해 얕은(shallow) 복사 필요
      // 참조 주소를 서로 분리해야한다.

      // 이전 방식: Object.assign 활용
      const obj3 = Object.assign({}, obj);
      // obj3.a === 10;

      obj.a = 20;
      console.log("obj3.a", obj3.a); // 10

      // es6 이후: spread(...) 문법 사용 (전개연산자)
      // {}, [] 등 감싸진 부분을 풀어버리는 역할
      // {a: 1, b: 2} -> a: 1, b: 2 -> {a: 1, b: 2}
      // 다른 객체에 풀어버린 property를 할당해주면 됨

      const obj4 = { ...obj }; // obj4.a === 20
      // obj.a === 20

      obj4.a = 100;

      console.log("--- obj4 ---");
      console.log("obj4.a", obj4.a); // 100
      console.log("obj.a", obj.a); // 20

      // 배열의 복사
      const arr = [1, 2, 3, 4, 5];
      // es5까지
      const arr2 = arr.slice();

      arr[2] = 100; // [1, 2, 100, 4, 5]

      console.log("arr2", arr2); // [1, 2, 3, 4, 5]
      console.log("arr", arr); // [1, 2, 100, 4, 5]

      // es6 이후 (spread 사용)
      const arr3 = [...arr]; // [1, 2, 100, 4, 5]
      arr3[arr3.length - 1] = 50;

      console.log("arr3", arr3); // [1, 2, 100, 4, 50]
      console.log("arr", arr); // [1, 2, 100, 4, 5]
    </script>
  </body>
</html>
